#include "JetTester.h"

JetTester::JetTester(){
}

JetTester::~JetTester(){
}

void JetTester::populate_F(void *obj, int (*f)(void *obj, const RealVector &state, int degree, JetMatrix &jm),
                           const RealVector &pmin, const RealVector &pmax,
                           const std::vector<unsigned long int> &subdivision,
                           MultiArray<RealVector> &F, MultiArray<DoubleMatrix> &JF){

    F.resize(subdivision);
    JF.resize(subdivision);

    //
    std::vector<std::vector<double> > coord(subdivision.size());
    for (int i = 0; i < coord.size(); i++){
        double delta = (pmax[i] - pmin[i])/(double)(subdivision[i] - 1);

        coord[i].resize(subdivision[i]);
        for (int j = 0; j < subdivision[i]; j++) coord[i][j] = pmin[i] + delta*((double)j);
    }

    // Use many times.
    //
    JetMatrix jm;
    RealVector point(subdivision.size());

    for (int i0 = 0; i0 < subdivision[0]; i0++){
        point(0) = coord[0][i0];

        for (int i1 = 0; i1 < subdivision[1]; i1++){
            point(1) = coord[1][i1];

            (*f)(obj, point, 1, jm);
            F(i0, i1)  = jm.function();
            JF(i0, i1) = jm.Jacobian();
        }
    }

    return;
}

void JetTester::numerical_Jacobian(const MultiArray<RealVector>    &F, 
                                   const MultiArray<DoubleMatrix> &JF,
                                   int rows, int cols, // rows and columns of the Jacobians, maybe there is a better way to do this.
                                   const RealVector &pmin, const RealVector &pmax,
                                   const std::vector<unsigned long int> &subdivision,
                                   /*MultiArray<DoubleMatrix> &numerical_analytic_deviation*/
                                   DoubleMatrix &numerical_analytic_abs_deviation_sup,
                                   double &synthetic_deviation){

    // Delta.
    //
    std::vector<double > inv_2_delta(subdivision.size());
    for (int i = 0; i < subdivision.size(); i++) inv_2_delta[i] = 1.0/(2.0*(pmax[i] - pmin[i])/(double)(subdivision[i] - 1));

    // Resize numerical_analytic_deviation.
    //
    std::vector<long unsigned int> range = F.range();
//    numerical_analytic_deviation.resize(range);

    //  
    //
    numerical_analytic_abs_deviation_sup = DoubleMatrix::zero(rows, cols);

    // Proceed.
    //
    for (int i0 = 1; i0 < range[0] - 1; i0++){
        for (int i1 = 1; i1 < range[1] - 1; i1++){
//                for (int m = 0; m < rows; m++){
//                    double dev0 = std::abs((F(i0 + 1, i1)(m) - F(i0 - 1, i1)(m))*inv_2_delta[0] - JF(i0, i1)(m, 0));
//                    double dev1 = std::abs((F(i0, i1 + 1)(m) - F(i0, i1 - 1)(m))*inv_2_delta[1] - JF(i0, i1)(m, 1));

////                    std::cout << "i0 = " << i0 << ", i1 = " << i1 << ", m = " << m << std::endl;

////                    double dev0 = std::abs((F(i0, i1 + 1)(0) - F(i0, i1 - 1)(0))*inv_2_delta[0]/* - JF(i0, i1)(m, 0)*/);
////                    std::cout << "    dev0 = " << (F(i0, i1 + 1)(0) - F(i0, i1 - 1)(0))*inv_2_delta[0] << " - " << JF(i0, i1)(m, 0) << std::endl; 

////                    double dev1 = std::abs((F(i0 + 1, i1)(1) - F(i0 - 1, i1)(1))*inv_2_delta[1]/* - JF(i0, i1)(m, 1)*/);
////                    std::cout << "    dev1 = " << (F(i0 + 1, i1)(1) - F(i0 - 1, i1)(1))*inv_2_delta[1] << " - " << JF(i0, i1)(m, 1) << std::endl; 

//                    numerical_analytic_abs_deviation_sup(m, 0) = std::max(numerical_analytic_abs_deviation_sup(m, 0), dev0);
//                    numerical_analytic_abs_deviation_sup(m, 1) = std::max(numerical_analytic_abs_deviation_sup(m, 1), dev1);

////                    numJac(m, i0) = dev0;
////                    numJac(m, i1) = dev1;
//                }

            DoubleMatrix numJac(rows, cols);
            for (int m = 0; m < rows; m++){
                numJac(m, 0) = (F(i0 + 1, i1)(m) - F(i0 - 1, i1)(m))*inv_2_delta[0];
                numJac(m, 1) = (F(i0, i1 + 1)(m) - F(i0, i1 - 1)(m))*inv_2_delta[1];
            }

            DoubleMatrix devJac = numJac - JF(i0, i1);

            for (int m = 0; m < rows; m++){
                for (int n = 0; n < cols; n++){
                    numerical_analytic_abs_deviation_sup(m, n) = std::max(numerical_analytic_abs_deviation_sup(m, n), devJac(m, n));
                }
            }


        } // i1
    } // i0

    synthetic_deviation = numerical_analytic_abs_deviation_sup.max();
    
    return;
}

void JetTester::test(void *obj, int (*f)(void *obj, const RealVector &state, int degree, JetMatrix &jm), 
                     const std::vector<int> &variables,
                     const RealVector &pmin, const RealVector &pmax,
                     const std::vector<unsigned long int> &subdivision,
                     std::vector<double> &min_error, 
                     std::vector<double> &max_error,
                     std::vector<double> &mean_value){

    min_error.clear();
    max_error.clear();
    mean_value.clear();

    MultiArray<RealVector>    F(subdivision);
    MultiArray<DoubleMatrix> JF(subdivision);

    populate_F(obj, f,
               pmin, pmax,
               subdivision,
               F, JF);

    for (int i = 0; i < variables.size(); i++){
        double delta = (pmax(i) - pmin(i))/(double)(subdivision[i] - 1);
        double min =  std::numeric_limits<double>::infinity();
        double max = -std::numeric_limits<double>::infinity();
        double mean = 0.0;

        for (int j = 0; j < subdivision[i]; j++){
            
        }

        min_error.push_back(min);
        max_error.push_back(max);
        mean_value.push_back(mean);
    }

    return;
}

